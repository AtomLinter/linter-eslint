"use strict";

var Path = _interopRequireWildcard(require("path"));

var _atomLinter = require("atom-linter");

var Helpers = _interopRequireWildcard(require("./worker-helpers"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* global emit */
process.title = 'linter-eslint helper';
const rulesMetadata = new Map();
let shouldSendRules = false;
/**
 * The return of {getCLIEngineOptions} function
 * @typedef {object} CliEngineOptions
 * @property {string[]} rules
 * @property {boolean} ignore
 * @property {boolean} fix
 * @property {string[]} rulePaths
 * @property {string | undefined} configFile
 */

/**
 * @param {import("eslint")} eslint
 * @param {CliEngineOptions} cliEngineOptions
 * @param {string} contents
 * @param {string} filePath
 */

function lintJobCLIEngine(eslint, cliEngineOptions, contents, filePath) {
  const cliEngine = new eslint.CLIEngine(cliEngineOptions);
  const report = cliEngine.executeOnText(contents, filePath);
  const rules = Helpers.getRules(cliEngine);
  shouldSendRules = Helpers.didRulesChange(rulesMetadata, rules);

  if (shouldSendRules) {
    // Rebuild rulesMetadata
    rulesMetadata.clear();
    rules.forEach((properties, rule) => rulesMetadata.set(rule, properties));
  }

  return report;
}
/**
 * @param {import("eslint")} eslint
 * @param {CliEngineOptions} cliEngineOptions
 * @param {string} contents
 * @param {string} filePath
 */


function fixJobCLIEngine(eslint, cliEngineOptions, contents, filePath) {
  const report = lintJobCLIEngine(eslint, cliEngineOptions, contents, filePath);
  eslint.CLIEngine.outputFixes(report);

  if (!report.results.length || !report.results[0].messages.length) {
    return 'Linter-ESLint: Fix complete.';
  }

  return 'Linter-ESLint: Fix attempt complete, but linting errors remain.';
}
/**
 * @param {string} type
 * @param {import("eslint")} eslint
 * @param {CliEngineOptions} cliEngineOptions
 * @param {string} contents
 * @param {string} filePath
 */


function executeCLIEngine(type, eslint, cliEngineOptions, contents, filePath) {
  if (type === 'lint') {
    const report = lintJobCLIEngine(eslint, cliEngineOptions, contents, filePath);
    return {
      messages: report.results.length ? report.results[0].messages : [],
      updatedRules: shouldSendRules ? Array.from(rulesMetadata) : undefined
    };
  }

  if (type === 'fix') {
    return fixJobCLIEngine(eslint, cliEngineOptions, contents, filePath);
  }

  return undefined;
}
/**
* The return of {getESLintOptions} function
* @typedef {object} ESLintOptions
* @property {object} overrideConfig
* @property {string[]} overrideConfig.rules
* @property {boolean} ignore
* @property {boolean} fix
* @property {string[]} rulePaths
* @property {string | undefined} overrideConfigFile
*/

/**
 * @param {import("eslint")} eslint
 * @param {ESLintOptions} eslintOptions
 * @param {string} contents
 * @param {string} filePath
 */


async function lintJobESLint(eslint, eslintOptions, contents, filePath) {
  const linter = new eslint.ESLint(eslintOptions);
  const report = await linter.lintText(contents, {
    filePath
  });
  const rules = Helpers.getRules(linter, report);
  shouldSendRules = Helpers.didRulesChange(rulesMetadata, rules);

  if (shouldSendRules) {
    // Rebuild rulesMetadata
    rulesMetadata.clear();
    rules.forEach((properties, rule) => rulesMetadata.set(rule, properties));
  }

  return report;
}
/**
 * @param {import("eslint")} eslint
 * @param {ESLintOptions} eslintOptions
 * @param {string} contents
 * @param {string} filePath
 */


async function fixJobESLint(eslint, eslintOptions, contents, filePath) {
  const report = await lintJobESLint(eslint, eslintOptions, contents, filePath);
  eslint.ESLint.outputFixes(report);

  if (!report.length || !report[0].messages.length) {
    return 'Linter-ESLint: Fix complete.';
  }

  return 'Linter-ESLint: Fix attempt complete, but linting errors remain.';
}
/**
 * @param {string} type
 * @param {import("eslint")} eslint
 * @param {ESLintOptions} eslintOptions
 * @param {string} contents
 * @param {string} filePath
 */


async function executeESLint(type, eslint, eslintOptions, contents, filePath) {
  if (type === 'lint') {
    const report = await lintJobESLint(eslint, eslintOptions, contents, filePath);
    return {
      messages: report.length ? report[0].messages : [],
      updatedRules: shouldSendRules ? Array.from(rulesMetadata) : undefined
    };
  }

  if (type === 'fix') {
    return fixJobESLint(eslint, eslintOptions, contents, filePath);
  }

  return undefined;
}

module.exports = async () => {
  process.on('message', async jobConfig => {
    // We catch all worker errors so that we can create a separate error emitter
    // for each emitKey, rather than adding multiple listeners for `task:error`
    const {
      contents,
      type,
      config,
      filePath,
      projectPath,
      rules,
      emitKey
    } = jobConfig;

    try {
      if (config.advanced.disableFSCache) {
        _atomLinter.FindCache.clear();
      }

      const fileDir = Path.dirname(filePath);
      const eslint = Helpers.getESLintInstance(fileDir, config, projectPath);
      const fileConfig = await Helpers.getConfigForFile(eslint, filePath);

      if (fileConfig === null && config.disabling.disableWhenNoEslintConfig) {
        emit(emitKey, {
          messages: []
        });
        return;
      }

      const relativeFilePath = Helpers.getRelativePath(fileDir, filePath, config, projectPath);
      let response;

      if (type === 'debug') {
        const modulesDir = Path.dirname((0, _atomLinter.findCached)(fileDir, 'node_modules/eslint') || '');
        response = Helpers.findESLintDirectory(modulesDir, config, projectPath);
      } else if (eslint.ESLint) {
        const eslintOptions = Helpers.getESLintOptions(type, config, rules, relativeFilePath, fileConfig);
        response = await executeESLint(type, eslint, eslintOptions, contents, filePath);
      } else if (eslint.CLIEngine) {
        const cliEngineOptions = Helpers.getCLIEngineOptions(type, config, rules, relativeFilePath, fileConfig);
        response = executeCLIEngine(type, eslint, cliEngineOptions, contents, filePath);
      }

      emit(emitKey, response);
    } catch (workerErr) {
      emit(`workerError:${emitKey}`, {
        msg: workerErr.message,
        stack: workerErr.stack
      });
    }
  });
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93b3JrZXIuanMiXSwibmFtZXMiOlsicHJvY2VzcyIsInRpdGxlIiwicnVsZXNNZXRhZGF0YSIsIk1hcCIsInNob3VsZFNlbmRSdWxlcyIsImxpbnRKb2JDTElFbmdpbmUiLCJlc2xpbnQiLCJjbGlFbmdpbmVPcHRpb25zIiwiY29udGVudHMiLCJmaWxlUGF0aCIsImNsaUVuZ2luZSIsIkNMSUVuZ2luZSIsInJlcG9ydCIsImV4ZWN1dGVPblRleHQiLCJydWxlcyIsIkhlbHBlcnMiLCJnZXRSdWxlcyIsImRpZFJ1bGVzQ2hhbmdlIiwiY2xlYXIiLCJmb3JFYWNoIiwicHJvcGVydGllcyIsInJ1bGUiLCJzZXQiLCJmaXhKb2JDTElFbmdpbmUiLCJvdXRwdXRGaXhlcyIsInJlc3VsdHMiLCJsZW5ndGgiLCJtZXNzYWdlcyIsImV4ZWN1dGVDTElFbmdpbmUiLCJ0eXBlIiwidXBkYXRlZFJ1bGVzIiwiQXJyYXkiLCJmcm9tIiwidW5kZWZpbmVkIiwibGludEpvYkVTTGludCIsImVzbGludE9wdGlvbnMiLCJsaW50ZXIiLCJFU0xpbnQiLCJsaW50VGV4dCIsImZpeEpvYkVTTGludCIsImV4ZWN1dGVFU0xpbnQiLCJtb2R1bGUiLCJleHBvcnRzIiwib24iLCJqb2JDb25maWciLCJjb25maWciLCJwcm9qZWN0UGF0aCIsImVtaXRLZXkiLCJhZHZhbmNlZCIsImRpc2FibGVGU0NhY2hlIiwiRmluZENhY2hlIiwiZmlsZURpciIsIlBhdGgiLCJkaXJuYW1lIiwiZ2V0RVNMaW50SW5zdGFuY2UiLCJmaWxlQ29uZmlnIiwiZ2V0Q29uZmlnRm9yRmlsZSIsImRpc2FibGluZyIsImRpc2FibGVXaGVuTm9Fc2xpbnRDb25maWciLCJlbWl0IiwicmVsYXRpdmVGaWxlUGF0aCIsImdldFJlbGF0aXZlUGF0aCIsInJlc3BvbnNlIiwibW9kdWxlc0RpciIsImZpbmRFU0xpbnREaXJlY3RvcnkiLCJnZXRFU0xpbnRPcHRpb25zIiwiZ2V0Q0xJRW5naW5lT3B0aW9ucyIs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QytCLE1BQVgsRUFBbUI7QUFDakIsY0FBTUYsYUFBYSxHQUFHcEIsT0FBTyxDQUFDa0QsZ0JBQVIsQ0FBeUJwQyxJQUF6QixFQUErQmdCLE1BQS9CLEVBQXVDL0IsS0FBdkMsRUFBOEM4QyxnQkFBOUMsRUFBZ0VMLFVBQWhFLENBQXRCO0FBQ0FPLFFBQUFBLFFBQVEsR0FBRyxNQUFNdEIsYUFBYSxDQUFDWCxJQUFELEVBQU92QixNQUFQLEVBQWU2QixhQUFmLEVBQThCM0IsUUFBOUIsRUFBd0NDLFFBQXhDLENBQTlCO0FBQ0QsT0FIRCxNQUtBLElBQUlILE1BQU0sQ0FBQ0ssU0FBWCxFQUFzQjtBQUNwQixjQUFNSixnQkFBZ0IsR0FBR1EsT0FBTyxDQUFDbUQsbUJBQVIsQ0FBNEJyQyxJQUE1QixFQUFrQ2dCLE1BQWxDLEVBQTBDL0IsS0FBMUMsRUFBaUQ4QyxnQkFBakQsRUFBbUVMLFVBQW5FLENBQXpCO0FBQ0FPLFFBQUFBLFFBQVEsR0FBR2xDLGdCQUFnQixDQUFDQyxJQUFELEVBQU92QixNQUFQLEVBQWVDLGdCQUFmLEVBQWlDQyxRQUFqQyxFQUEyQ0MsUUFBM0MsQ0FBM0I7QUFDRDs7QUFFRGtELE1BQUFBLElBQUksQ0FBQ1osT0FBRCxFQUFVZSxRQUFWLENBQUo7QUFDRCxLQWpDRCxDQWlDRSxPQUFPSyxTQUFQLEVBQWtCO0FBQ2xCUixNQUFBQSxJQUFJLENBQUUsZUFBY1osT0FBUSxFQUF4QixFQUEyQjtBQUFFcUIsUUFBQUEsR0FBRyxFQUFFRCxTQUFTLENBQUNFLE9BQWpCO0FBQTBCQyxRQUFBQSxLQUFLLEVBQUVILFNBQVMsQ0FBQ0c7QUFBM0MsT0FBM0IsQ0FBSjtBQUNEO0FBQ0YsR0ExQ0Q7QUEyQ0QsQ0E1Q0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgZW1pdCAqL1xuXG5pbXBvcnQgKiBhcyBQYXRoIGZyb20gJ3BhdGgnXG5pbXBvcnQgeyBGaW5kQ2FjaGUsIGZpbmRDYWNoZWQgfSBmcm9tICdhdG9tLWxpbnRlcidcbmltcG9ydCAqIGFzIEhlbHBlcnMgZnJvbSAnLi93b3JrZXItaGVscGVycydcblxucHJvY2Vzcy50aXRsZSA9ICdsaW50ZXItZXNsaW50IGhlbHBlcidcblxuY29uc3QgcnVsZXNNZXRhZGF0YSA9IG5ldyBNYXAoKVxubGV0IHNob3VsZFNlbmRSdWxlcyA9IGZhbHNlXG5cbi8qKlxuICogVGhlIHJldHVybiBvZiB7Z2V0Q0xJRW5naW5lT3B0aW9uc30gZnVuY3Rpb25cbiAqIEB0eXBlZGVmIHtvYmplY3R9IENsaUVuZ2luZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHJ1bGVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlnbm9yZVxuICogQHByb3BlcnR5IHtib29sZWFufSBmaXhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHJ1bGVQYXRoc1xuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IGNvbmZpZ0ZpbGVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiZXNsaW50XCIpfSBlc2xpbnRcbiAqIEBwYXJhbSB7Q2xpRW5naW5lT3B0aW9uc30gY2xpRW5naW5lT3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGhcbiAqL1xuZnVuY3Rpb24gbGludEpvYkNMSUVuZ2luZShlc2xpbnQsIGNsaUVuZ2luZU9wdGlvbnMsIGNvbnRlbnRzLCBmaWxlUGF0aCkge1xuICBjb25zdCBjbGlFbmdpbmUgPSBuZXcgZXNsaW50LkNMSUVuZ2luZShjbGlFbmdpbmVPcHRpb25zKVxuICBjb25zdCByZXBvcnQgPSBjbGlFbmdpbmUuZXhlY3V0ZU9uVGV4dChjb250ZW50cywgZmlsZVBhdGgpXG4gIGNvbnN0IHJ1bGVzID0gSGVscGVycy5nZXRSdWxlcyhjbGlFbmdpbmUpXG4gIHNob3VsZFNlbmRSdWxlcyA9IEhlbHBlcnMuZGlkUnVsZXNDaGFuZ2UocnVsZXNNZXRhZGF0YSwgcnVsZXMpXG4gIGlmIChzaG91bGRTZW5kUnVsZXMpIHtcbiAgICAvLyBSZWJ1aWxkIHJ1bGVzTWV0YWRhdGFcbiAgICBydWxlc01ldGFkYXRhLmNsZWFyKClcbiAgICBydWxlcy5mb3JFYWNoKChwcm9wZXJ0aWVzLCBydWxlKSA9PiBydWxlc01ldGFkYXRhLnNldChydWxlLCBwcm9wZXJ0aWVzKSlcbiAgfVxuICByZXR1cm4gcmVwb3J0XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCJlc2xpbnRcIil9IGVzbGludFxuICogQHBhcmFtIHtDbGlFbmdpbmVPcHRpb25zfSBjbGlFbmdpbmVPcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aFxuICovXG5mdW5jdGlvbiBmaXhKb2JDTElFbmdpbmUoZXNsaW50LCBjbGlFbmdpbmVPcHRpb25zLCBjb250ZW50cywgZmlsZVBhdGgpIHtcbiAgY29uc3QgcmVwb3J0ID0gbGludEpvYkNMSUVuZ2luZShlc2xpbnQsIGNsaUVuZ2luZU9wdGlvbnMsIGNvbnRlbnRzLCBmaWxlUGF0aClcblxuICBlc2xpbnQuQ0xJRW5naW5lLm91dHB1dEZpeGVzKHJlcG9ydClcblxuICBpZiAoIXJlcG9ydC5yZXN1bHRzLmxlbmd0aCB8fCAhcmVwb3J0LnJlc3VsdHNbMF0ubWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdMaW50ZXItRVNMaW50OiBGaXggY29tcGxldGUuJ1xuICB9XG4gIHJldHVybiAnTGludGVyLUVTTGludDogRml4IGF0dGVtcHQgY29tcGxldGUsIGJ1dCBsaW50aW5nIGVycm9ycyByZW1haW4uJ1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge2ltcG9ydChcImVzbGludFwiKX0gZXNsaW50XG4gKiBAcGFyYW0ge0NsaUVuZ2luZU9wdGlvbnN9IGNsaUVuZ2luZU9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVQYXRoXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVDTElFbmdpbmUodHlwZSwgZXNsaW50LCBjbGlFbmdpbmVPcHRpb25zLCBjb250ZW50cywgZmlsZVBhdGgpIHtcbiAgaWYgKHR5cGUgPT09ICdsaW50Jykge1xuICAgIGNvbnN0IHJlcG9ydCA9IGxpbnRKb2JDTElFbmdpbmUoZXNsaW50LCBjbGlFbmdpbmVPcHRpb25zLCBjb250ZW50cywgZmlsZVBhdGgpXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2VzOiByZXBvcnQucmVzdWx0cy5sZW5ndGggPyByZXBvcnQucmVzdWx0c1swXS5tZXNzYWdlcyA6IFtdLFxuICAgICAgdXBkYXRlZFJ1bGVzOiBzaG91bGRTZW5kUnVsZXMgPyBBcnJheS5mcm9tKHJ1bGVzTWV0YWRhdGEpIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdmaXgnKSB7XG4gICAgcmV0dXJuIGZpeEpvYkNMSUVuZ2luZShlc2xpbnQsIGNsaUVuZ2luZU9wdGlvbnMsIGNvbnRlbnRzLCBmaWxlUGF0aClcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuLyoqXG4qIFRoZSByZXR1cm4gb2Yge2dldEVTTGludE9wdGlvbnN9IGZ1bmN0aW9uXG4qIEB0eXBlZGVmIHtvYmplY3R9IEVTTGludE9wdGlvbnNcbiogQHByb3BlcnR5IHtvYmplY3R9IG92ZXJyaWRlQ29uZmlnXG4qIEBwcm9wZXJ0eSB7c3RyaW5nW119IG92ZXJyaWRlQ29uZmlnLnJ1bGVzXG4qIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWdub3JlXG4qIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZml4XG4qIEBwcm9wZXJ0eSB7c3RyaW5nW119IHJ1bGVQYXRoc1xuKiBAcHJvcGVydHkge3N0cmluZyB8IHVuZGVmaW5lZH0gb3ZlcnJpZGVDb25maWdGaWxlXG4qL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiZXNsaW50XCIpfSBlc2xpbnRcbiAqIEBwYXJhbSB7RVNMaW50T3B0aW9uc30gZXNsaW50T3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGhcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGludEpvYkVTTGludChlc2xpbnQsIGVzbGludE9wdGlvbnMsIGNvbnRlbnRzLCBmaWxlUGF0aCkge1xuICBjb25zdCBsaW50ZXIgPSBuZXcgZXNsaW50LkVTTGludChlc2xpbnRPcHRpb25zKVxuICBjb25zdCByZXBvcnQgPSBhd2FpdCBsaW50ZXIubGludFRleHQoY29udGVudHMsIHsgZmlsZVBhdGggfSlcbiAgY29uc3QgcnVsZXMgPSBIZWxwZXJzLmdldFJ1bGVzKGxpbnRlciwgcmVwb3J0KVxuICBzaG91bGRTZW5kUnVsZXMgPSBIZWxwZXJzLmRpZFJ1bGVzQ2hhbmdlKHJ1bGVzTWV0YWRhdGEsIHJ1bGVzKVxuICBpZiAoc2hvdWxkU2VuZFJ1bGVzKSB7XG4gICAgLy8gUmVidWlsZCBydWxlc01ldGFkYXRhXG4gICAgcnVsZXNNZXRhZGF0YS5jbGVhcigpXG4gICAgcnVsZXMuZm9yRWFjaCgocHJvcGVydGllcywgcnVsZSkgPT4gcnVsZXNNZXRhZGF0YS5zZXQocnVsZSwgcHJvcGVydGllcykpXG4gIH1cbiAgcmV0dXJuIHJlcG9ydFxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiZXNsaW50XCIpfSBlc2xpbnRcbiAqIEBwYXJhbSB7RVNMaW50T3B0aW9uc30gZXNsaW50T3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGhcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZml4Sm9iRVNMaW50KGVzbGludCwgZXNsaW50T3B0aW9ucywgY29udGVudHMsIGZpbGVQYXRoKSB7XG4gIGNvbnN0IHJlcG9ydCA9IGF3YWl0IGxpbnRKb2JFU0xpbnQoZXNsaW50LCBlc2xpbnRPcHRpb25zLCBjb250ZW50cywgZmlsZVBhdGgpXG5cbiAgZXNsaW50LkVTTGludC5vdXRwdXRGaXhlcyhyZXBvcnQpXG5cbiAgaWYgKCFyZXBvcnQubGVuZ3RoIHx8ICFyZXBvcnRbMF0ubWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdMaW50ZXItRVNMaW50OiBGaXggY29tcGxldGUuJ1xuICB9XG4gIHJldHVybiAnTGludGVyLUVTTGludDogRml4IGF0dGVtcHQgY29tcGxldGUsIGJ1dCBsaW50aW5nIGVycm9ycyByZW1haW4uJ1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge2ltcG9ydChcImVzbGludFwiKX0gZXNsaW50XG4gKiBAcGFyYW0ge0VTTGludE9wdGlvbnN9IGVzbGludE9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVQYXRoXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVFU0xpbnQodHlwZSwgZXNsaW50LCBlc2xpbnRPcHRpb25zLCBjb250ZW50cywgZmlsZVBhdGgpIHtcbiAgaWYgKHR5cGUgPT09ICdsaW50Jykge1xuICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IGxpbnRKb2JFU0xpbnQoZXNsaW50LCBlc2xpbnRPcHRpb25zLCBjb250ZW50cywgZmlsZVBhdGgpXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2VzOiByZXBvcnQubGVuZ3RoID8gcmVwb3J0WzBdLm1lc3NhZ2VzIDogW10sXG4gICAgICB1cGRhdGVkUnVsZXM6IHNob3VsZFNlbmRSdWxlcyA/IEFycmF5LmZyb20ocnVsZXNNZXRhZGF0YSkgOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2ZpeCcpIHtcbiAgICByZXR1cm4gZml4Sm9iRVNMaW50KGVzbGludCwgZXNsaW50T3B0aW9ucywgY29udGVudHMsIGZpbGVQYXRoKVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jICgpID0+IHtcbiAgcHJvY2Vzcy5vbignbWVzc2FnZScsIGFzeW5jIChqb2JDb25maWcpID0+IHtcbiAgICAvLyBXZSBjYXRjaCBhbGwgd29ya2VyIGVycm9ycyBzbyB0aGF0IHdlIGNhbiBjcmVhdGUgYSBzZXBhcmF0ZSBlcnJvciBlbWl0dGVyXG4gICAgLy8gZm9yIGVhY2ggZW1pdEtleSwgcmF0aGVyIHRoYW4gYWRkaW5nIG11bHRpcGxlIGxpc3RlbmVycyBmb3IgYHRhc2s6ZXJyb3JgXG4gICAgY29uc3Qge1xuICAgICAgY29udGVudHMsIHR5cGUsIGNvbmZpZywgZmlsZVBhdGgsIHByb2plY3RQYXRoLCBydWxlcywgZW1pdEtleVxuICAgIH0gPSBqb2JDb25maWdcbiAgICB0cnkge1xuICAgICAgaWYgKGNvbmZpZy5hZHZhbmNlZC5kaXNhYmxlRlNDYWNoZSkge1xuICAgICAgICBGaW5kQ2FjaGUuY2xlYXIoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWxlRGlyID0gUGF0aC5kaXJuYW1lKGZpbGVQYXRoKVxuICAgICAgY29uc3QgZXNsaW50ID0gSGVscGVycy5nZXRFU0xpbnRJbnN0YW5jZShmaWxlRGlyLCBjb25maWcsIHByb2plY3RQYXRoKVxuXG4gICAgICBjb25zdCBmaWxlQ29uZmlnID0gYXdhaXQgSGVscGVycy5nZXRDb25maWdGb3JGaWxlKGVzbGludCwgZmlsZVBhdGgpXG4gICAgICBpZiAoZmlsZUNvbmZpZyA9PT0gbnVsbCAmJiBjb25maWcuZGlzYWJsaW5nLmRpc2FibGVXaGVuTm9Fc2xpbnRDb25maWcpIHtcbiAgICAgICAgZW1pdChlbWl0S2V5LCB7IG1lc3NhZ2VzOiBbXSB9KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVsYXRpdmVGaWxlUGF0aCA9IEhlbHBlcnMuZ2V0UmVsYXRpdmVQYXRoKGZpbGVEaXIsIGZpbGVQYXRoLCBjb25maWcsIHByb2plY3RQYXRoKVxuXG4gICAgICBsZXQgcmVzcG9uc2VcbiAgICAgIGlmICh0eXBlID09PSAnZGVidWcnKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZXNEaXIgPSBQYXRoLmRpcm5hbWUoZmluZENhY2hlZChmaWxlRGlyLCAnbm9kZV9tb2R1bGVzL2VzbGludCcpIHx8ICcnKVxuICAgICAgICByZXNwb25zZSA9IEhlbHBlcnMuZmluZEVTTGludERpcmVjdG9yeShtb2R1bGVzRGlyLCBjb25maWcsIHByb2plY3RQYXRoKVxuICAgICAgfSBlbHNlXG5cbiAgICAgIGlmIChlc2xpbnQuRVNMaW50KSB7XG4gICAgICAgIGNvbnN0IGVzbGludE9wdGlvbnMgPSBIZWxwZXJzLmdldEVTTGludE9wdGlvbnModHlwZSwgY29uZmlnLCBydWxlcywgcmVsYXRpdmVGaWxlUGF0aCwgZmlsZUNvbmZpZylcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBleGVjdXRlRVNMaW50KHR5cGUsIGVzbGludCwgZXNsaW50T3B0aW9ucywgY29udGVudHMsIGZpbGVQYXRoKVxuICAgICAgfSBlbHNlXG5cbiAgICAgIGlmIChlc2xpbnQuQ0xJRW5naW5lKSB7XG4gICAgICAgIGNvbnN0IGNsaUVuZ2luZU9wdGlvbnMgPSBIZWxwZXJzLmdldENMSUVuZ2luZU9wdGlvbnModHlwZSwgY29uZmlnLCBydWxlcywgcmVsYXRpdmVGaWxlUGF0aCwgZmlsZUNvbmZpZylcbiAgICAgICAgcmVzcG9uc2UgPSBleGVjdXRlQ0xJRW5naW5lKHR5cGUsIGVzbGludCwgY2xpRW5naW5lT3B0aW9ucywgY29udGVudHMsIGZpbGVQYXRoKVxuICAgICAgfVxuXG4gICAgICBlbWl0KGVtaXRLZXksIHJlc3BvbnNlKVxuICAgIH0gY2F0Y2ggKHdvcmtlckVycikge1xuICAgICAgZW1pdChgd29ya2VyRXJyb3I6JHtlbWl0S2V5fWAsIHsgbXNnOiB3b3JrZXJFcnIubWVzc2FnZSwgc3RhY2s6IHdvcmtlckVyci5zdGFjayB9KVxuICAgIH1cbiAgfSlcbn1cbiJdfQ==